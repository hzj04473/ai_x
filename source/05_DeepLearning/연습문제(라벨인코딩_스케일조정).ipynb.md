# 데이터 전처리 연습: 인코딩과 스케일링 마스터하기

훌륭한 머신러닝 모델을 만드는 여정은 언제나 **깨끗하고 잘 정돈된 데이터**에서 시작합니다. `연습문제(라벨인코딩_스케일조정).ipynb` 노트북은 모델을 학습시키기 전, 데이터를 "정제"하는 가장 기본적이고 필수적인 두 가지 기술, **레이블 인코딩(Label Encoding)**과 **피처 스케일링(Feature Scaling)**을 연습하는 데 초점을 맞추고 있습니다.

이 문서는 해당 노트북의 코드를 따라가며 각 전처리 단계가 왜 필요하고 어떻게 수행되는지 상세히 설명합니다.

## 1. 데이터 준비: 전국 평당 분양가격 데이터

먼저 분석할 데이터를 불러옵니다.

```python
import pandas as pd

df = pd.read_csv('./data/최종전국평당분양가격(결측치제외).csv', 
                 encoding='cp949')
df.head()
```
- **데이터셋**: 전국의 지역별, 연도별, 월별 아파트 평당 분양가격 정보를 담고 있습니다.
- **`encoding='cp949'`**: CSV 파일에 '서울', '부산'과 같은 한글 데이터가 포함되어 있을 때, 파일이 깨지지 않고 올바르게 읽히도록 인코딩 방식을 지정해주는 중요한 옵션입니다.

## 2. 레이블 인코딩: 문자를 숫자로 변환하기

머신러닝 모델은 '서울', '부산'과 같은 문자열 데이터를 직접 이해할 수 없습니다. 따라서 이러한 범주형(Categorical) 데이터를 숫자 형태로 바꿔주는 과정이 필요합니다.

- **레이블 인코딩 (Label Encoding)**: 각 문자열 카테고리에 고유한 정수(레이블)를 부여하는 방법입니다.

```python
from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

# '지역명' 컬럼을 레이블 인코딩하여 '지역명2'라는 새로운 컬럼에 저장
df['지역명2'] = le.fit_transform(df['지역명'])
```
- `fit_transform()`: `fit`과 `transform`을 한 번에 수행하는 편리한 함수입니다.
    1.  `fit`: '지역명' 컬럼에 어떤 종류의 지역들이 있는지 학습합니다. (예: 서울, 부산, 대구...)
    2.  `transform`: 학습된 내용을 바탕으로 각 지역명을 해당하는 숫자(0, 1, 2...)로 변환합니다.
- 이 과정을 통해 우리는 모델이 이해할 수 있는 숫자형 특성 `지역명2`를 얻게 됩니다.

## 3. 피처 스케일링: 변수들의 단위를 맞추는 작업

데이터를 살펴보면, '연도'(~2020), '월'(1~12), '평당분양가격'(~수만) 등 각 변수(Feature)들이 가진 값의 범위(스케일)가 매우 다른 것을 알 수 있습니다. 이렇게 스케일이 크게 차이 나면, 값이 큰 변수가 모델 학습에 지나치게 큰 영향을 주어 학습이 불안정해지거나 결과가 왜곡될 수 있습니다. **피처 스케일링**은 모든 변수들의 단위를 비슷한 수준으로 맞춰주는 중요한 과정입니다.

### 3.1. 정규화 (Normalization): Min-Max 스케일링

- **원리**: 모든 데이터 값을 0과 1 사이의 범위로 압축합니다. 가장 작은 값은 0, 가장 큰 값은 1이 됩니다.
- **언제 사용하나?**: 데이터의 분포가 비교적 고르거나, 값의 범위를 명확하게 0과 1 사이로 제한하고 싶을 때 유용합니다.

```python
from sklearn.preprocessing import MinMaxScaler

x_scaler = MinMaxScaler()
y_scaler = MinMaxScaler()

# 독립 변수들을 0~1 사이로 정규화
df[['지역명2n','연도n','월n']] = x_scaler.fit_transform(X_data)

# 종속 변수를 0~1 사이로 정규화
df[['평당분양가격n']] = y_scaler.fit_transform(Y_data)
```

### 3.2. 표준화 (Standardization)

- **원리**: 데이터의 분포를 평균이 0, 표준편차가 1이 되도록 변환합니다. 값의 범위가 특정하게 정해지지는 않지만, 대부분의 값이 -2와 2 사이에 분포하게 됩니다.
- **언제 사용하나?**: 데이터에 이상치(Outlier, 다른 값들과 매우 동떨어진 값)가 있을 때 정규화보다 더 안정적인 성능을 보입니다. 많은 머신러닝 알고리즘에서 기본적으로 선호되는 스케일링 방식입니다.

```python
from sklearn.preprocessing import StandardScaler

x_scaler_s = StandardScaler()
y_scaler_s = StandardScaler()

df[['지역명2s','연도s','월s']] = x_scaler_s.fit_transform(X_data)
df[['평당분양가격s']] = y_scaler_s.fit_transform(Y_data)
```

## 4. 원-핫 인코딩: 범주형 데이터의 올바른 표현

레이블 인코딩은 간단하지만 한 가지 잠재적인 문제가 있습니다. 모델이 숫자 레이블(0, 1, 2...) 간에 순서나 크기 관계가 있다고 오해할 수 있다는 점입니다. (예: '서울'(8)이 '부산'(7)보다 더 중요하다거나 크다고 잘못 학습)

이러한 오해를 막기 위해 **원-핫 인코딩(One-Hot Encoding)**을 사용합니다. 각 지역명을 고유한 위치만 1이고 나머지는 0인 벡터로 표현하여, 모든 지역이 동등한 관계임을 명확히 해줍니다.

```python
# '지역명2' 컬럼을 원-핫 인코딩
one_hot = to_categorical(df['지역명2'])

# 원-핫 인코딩된 결과를 새로운 컬럼들로 데이터프레임에 추가
df[loc_column_names] = one_hot.astype(np.int16)
```
- 이 과정을 거치면 '서울'은 `[...0, 1, 0...]`, '부산'은 `[...1, 0, 0...]` 과 같이 독립적인 벡터로 표현되어 모델이 더 정확하게 특성을 학습할 수 있습니다.

## 5. 핵심 요약

- **`encoding='cp949'`**: 한글 데이터가 포함된 파일을 다룰 때 필수입니다.
- **레이블 인코딩**: 문자열 범주를 숫자로 변환하는 첫 단계입니다. (`LabelEncoder`)
- **피처 스케일링**: 서로 다른 단위와 범위를 가진 변수들을 비슷한 스케일로 맞춰 모델 학습을 안정화시킵니다. (`MinMaxScaler`, `StandardScaler`)
- **원-핫 인코딩**: 범주 간에 순서 관계가 없음을 명확히 하여 모델의 오해를 막는 더 발전된 인코딩 방식입니다. (`to_categorical`, `pd.get_dummies`)

이 노트북은 모든 머신러닝 프로젝트의 가장 기본이 되는 데이터 전처리 기술들을 종합적으로 연습할 수 있는 훌륭한 자료입니다.
